# 平衡树作业

## P3369 【模板】普通平衡树

真·模板

```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>
# define ll long long
using namespace std;
const int MAXN = 100051;
const int MAXM = 1000051;
struct Treep{
	struct Node{
		int rnd, val, sz;
		Node *ls, *rs;
	} pool[MAXN + MAXM];
	Node *rt;
	int sz;
	Node* new_node(){
		sz++;
		(pool + sz) -> rnd = rand();
		(pool + sz) -> sz = 1;
		return pool + sz;
	}
	void update(Node *nw){
		nw -> sz = 1;
		if (nw -> ls) nw -> sz += nw -> ls -> sz;
		if (nw -> rs) nw -> sz += nw -> rs -> sz;
	}
	void split_val(Node *nw, Node *&lft, Node *&rgt, int val){
		// printf("split_val %d\n", val);
		if (!nw) lft = rgt = NULL;
		else if (nw -> val <= val){
			lft = nw;
			split_val(nw -> rs, lft -> rs, rgt, val);
		} else {
			rgt = nw;
			split_val(nw -> ls, lft, rgt -> ls, val);
		}
		if (lft) update(lft);
		if (rgt) update(rgt);
	}
	void split_rank(Node *nw, Node *&lft, Node *&rgt, int rk){
		if (!nw){
			lft = rgt = NULL;
			return;
		}
		int nwrk = (nw -> ls) ? nw -> ls -> sz + 1 : 1;
		// printf("split_rank %d %d %d\n", rk, nwrk, nw -> sz);
		if (nwrk <= rk){
			lft = nw;
			// printf("???\n");
			split_rank(nw -> rs, lft -> rs, rgt, rk - nwrk);
		} else {
			rgt = nw;
			split_rank(nw -> ls, lft, rgt -> ls, rk);
		}
		if (lft) update(lft);
		if (rgt) update(rgt);
	}
	Node* merge(Node *lft, Node *rgt){
		if (!lft) return rgt;
		if (!rgt) return lft;
		Node *nw;
		if (lft -> rnd < rgt -> rnd){
			lft -> rs = merge(lft -> rs, rgt);
			nw = lft;
		} else {
			rgt -> ls = merge(lft, rgt -> ls);
			nw = rgt;
		}
		if (nw) update(nw);
		return nw;
	}
	void insert(int val){
		Node *lft, *rgt, *mid = new_node();
		mid -> val = val;
		// printf("insert\n");
		split_val(rt, lft, rgt, val);
		lft = merge(lft, mid);
		rt = merge(lft, rgt);
		// printf("rtsz %d\n", rt -> sz);
	}
	void del(int val){
		Node *lft, *rgt, *mid;
		split_val(rt, lft, rgt, val);
		split_rank(lft, lft, mid, lft -> sz - 1);
		rt = merge(lft, rgt);
	}
	int getrank(int val){
		Node *lft, *rgt;
		split_val(rt, lft, rgt, val - 1);
		int ans = (lft) ? lft -> sz + 1 : 1;
		rt = merge(lft, rgt);
		return ans;
	}
	int getval(int rk){
		Node *lft, *rgt, *mid;
		split_rank(rt, lft, rgt, rk);
		split_rank(lft, lft, mid, rk - 1);
		int ans = mid -> val;
		lft = merge(lft, mid);
		rt = merge(lft, rgt);
		return ans;
	}
	int getpre(int val){
		Node *lft, *rgt, *mid;
		split_val(rt, lft, rgt, val - 1);
		split_rank(lft, lft, mid, lft -> sz - 1);
		int ans = mid -> val;
		lft = merge(lft, mid);
		rt = merge(lft, rgt);
		return ans;
	}
	int getsuc(int val){
		Node *lft, *rgt, *mid;
		split_val(rt, lft, rgt, val);
		split_rank(rgt, mid, rgt, 1);
		int ans = mid -> val;
		rgt = merge(mid, rgt);
		rt = merge(lft, rgt);
		return ans;
	}
} t;
int n, m;
int a[MAXN];
int main(){
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		int op, x;
		scanf("%d%d", &op, &x);
		switch (op){
			case 1: t.insert(x); break;
			case 2: t.del(x); break;
			case 3: printf("%d\n", t.getrank(x)); break;
			case 4: printf("%d\n", t.getval(x)); break;
			case 5: printf("%d\n", t.getpre(x)); break;
			case 6: printf("%d\n", t.getsuc(x)); break;
		}
	}
	return 0;
}
```

## P3391 【模板】文艺平衡树

将翻转操用懒标记的方式记在每个节点上，pushdown的时候就交换子节点的左右孩子，并且变化子节点的翻转标记

## AcWing 266. 超级备忘录

## P4146 序列终结者

```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>
# define ll long long
using namespace std;
const int NR = 50051;
struct Treap{
	ll sz, rnd, tag, nm, a;
	int ls, rs;
	bool roll;
} t[NR];
int n, m, rt;
void push_down(int x){
	t[x].nm += t[x].tag;
	t[x].a += t[x].tag;
	if (t[x].ls) t[t[x].ls].tag += t[x].tag;
	if (t[x].rs) t[t[x].rs].tag += t[x].tag;
	t[x].tag = 0;
	if (!t[x].roll) return;
	if (t[x].ls) t[t[x].ls].roll ^= true;
	if (t[x].rs) t[t[x].rs].roll ^= true;
	swap(t[x].ls, t[x].rs);
	t[x].roll = false;
}
void update(int x){
	t[x].sz = t[t[x].ls].sz + t[t[x].rs].sz + 1;
	t[x].nm = max(t[x].a, max(t[t[x].ls].nm + t[t[x].ls].tag, t[t[x].rs].nm + t[t[x].rs].tag));
}
int merge(int lft, int rgt){
	if (!lft || !rgt) return lft + rgt;
	int fnl;
	if (t[lft].rnd < t[rgt].rnd){
		fnl = lft;
		push_down(fnl);
		t[lft].rs = merge(t[lft].rs, rgt);
	} else {
		fnl = rgt;
		push_down(fnl);
		t[rgt].ls = merge(lft, t[rgt].ls);
	}
	update(fnl);
	return fnl;
}
void split(int nw, int &lft, int &rgt, int rk){
	if (!nw){
		lft = rgt = 0;
		return;
	}
	push_down(nw);
	int nwrk = t[t[nw].ls].sz + 1;
	if (nwrk >= rk){
		rgt = nw;
		split(t[nw].ls, lft, t[nw].ls, rk);
	} else {
		lft = nw;
		split(t[nw].rs, t[nw].rs, rgt, rk - nwrk);
	}
	update(nw);
}
void modify1(int l, int r, ll k){
	int lft, mid, rgt;
	split(rt, mid, rgt, r + 1);
	split(mid, lft, mid, l);
	t[mid].tag += k;
	mid = merge(lft, mid);
	rt = merge(mid, rgt);
}
void modify2(int l, int r){
	int lft, mid, rgt;
	split(rt, mid, rgt, r + 1);
	split(mid, lft, mid, l);
	t[mid].roll ^= true;
	mid = merge(lft, mid);
	rt = merge(mid, rgt);
}
ll getmax(int l, int r){
	int lft, mid, rgt;
	ll ans;
	split(rt, mid, rgt, r + 1);
	split(mid, lft, mid, l);
	ans = t[mid].nm + t[mid].tag;
	mid = merge(lft, mid);
	rt = merge(mid, rgt);
	return ans;
}
int main(){
	srand(111112);
	t[0].nm = -1e18;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		t[i].sz = 1;
		t[i].rnd = rand();
		rt = merge(rt, i);
	}
	for (int i = 1; i <= m; i++){
		int op, lft, rgt;
		ll v;
		scanf("%d", &op);
		if (op == 1){
			scanf("%d%d%lld", &lft, &rgt, &v);
			modify1(lft, rgt, v);
		} else if (op == 2){
			scanf("%d%d", &lft, &rgt);
			modify2(lft, rgt);
		} else {
			scanf("%d%d", &lft, &rgt);
			printf("%lld\n", getmax(lft, rgt));
		}
	}
	return 0;
}
```